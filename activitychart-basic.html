<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="d3-import.html">


<!--
`activitychart-basic`
This component shows an activity history, similar to the colored github chart

@demo demo/activitychart_basic_demo.html
-->
<dom-module id="activitychart-basic">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>

    <iron-ajax
        id="ajaxCaller"
        url="[[dataurl]]"
        handle-as="json"
        on-response="handleResponse"
        debounce-duration="300">
    </iron-ajax>
    <div style="display:none;">{{dataset}}</div>
    <div id="diagram"></div>
  </template>

  <script>
    Polymer({
      is: 'activitychart-basic',

      properties: {
        /** URL of data to be plotted */
        dataurl: {
          type: String,
          value: '',
        },
        /** y values in JSON format (data to be displayed) */
        dataset: {
          type: Array,
        },
        /** x values in JSON format (labels for data) */
        labels: {
          type: Array,
        },
        /** Primary color of chart; formats supported are Hex, Short Hex, RGB (absolute), RGB (percentual), RGBA (absolute), RGBA (percentual), keyword (e.g. 'white'), HSL and HSLA */
        primarycolor: {
          type: String,
          value: '#930517',
        },
        /** Accent color of chart; formats supported are Hex, Short Hex, RGB (absolute), RGB (percentual), RGBA (absolute), RGBA (percentual), keyword (e.g. 'white'), HSL and HSLA  */
        accentcolor: {
          type: String,
          value: '#F5E8BB',
        },
        /** Number of colored dots per column (opt, default 8) */
        squaresPerColumn: {
          type: Number,
          value: 8,
        },
        /** Width of square (opt, default: 15) */
        squareWidth: {
          type: Number,
          value: 15,
        },
        /** Spacing of squares (opt, default: 20) */
        squareSpacing: {
          type: Number,
          value: 20,
        },
        //this could also be solved by setting value to a function calculating the default min/max value from the dataset (but only if we receive the dataset as a JSON object isntead of just receiving a URL)
        /** Minimum value from the dataset that is used for the color scale can be overwritten. */
        minValue: {
          type: Number,
          value: null
        },
        /** Maximum value from the dataset that is used for the color scale can be overwritten. */
        maxValue: {
          type: Number,
          value: null
        },
        /** Labels for x and y axis.
        Please provide as {'x': {'label': String}, 'y': {'label': String, 'values': String[]}}
        The correct labels for the x axis are chosen programmatically based on the data.*/
        axisLabels: {
          type: Object,
          value: {
            "x": {
              "label": "Tag"
            },
            "y": {
          		"label": "Stunde",
              "values": ["00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00", "08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00", "16:00", "17:00", "18:00", "19:00", "20:00", "21:00", "22:00", "23:00"]
            }
          }
        }
      },

      attached: function() {
        if(this.dataurl != "") {
          this.$.ajaxCaller.generateRequest();
        }
        else {
          this._plotDiagram();
        }
      },
      /**
      * Transforms the transmitted data into a plot
      *
      * @param {Object} data The data to be plotted
      */
      handleResponse: function (data) {
        var goodData = this._normalizeJSON(data.detail.response);
        this.dataset = goodData[0]["y"];
        this.labels = goodData[0]["x"];
        this._plotDiagram();
      },

      _buildDataset: function(labels, dataset) {
        // create data like this:
        // [ {'x': timeStamp0, 'y': value0}, ... ,{'x': timeStampN, 'y': valueN}]
        var data = [];
        for(var j = 0; j < labels.length; j++) {
          data[j] = {'x': labels[j], 'y': dataset[j]};
        }
        return data;
      },

      _plotDiagram: function () {
        console.log("Plotting...");
        console.log(this.dataset);
        console.log(this.labels);
        var diagramDiv = this.$.diagram;

        var data = this._buildDataset(this.labels, this.dataset);

        var dataset = this.dataset;

        var datasetMin;
        if(this.minValue == null) {
          datasetMin = Math.min(...dataset);
        } else {
          datasetMin = this.minValue;
        }

        var datasetMax;
        if(this.maxValue == null) {
          datasetMax = Math.max(...dataset);
        } else {
          datasetMax = this.maxValue;
        }

        var svgWidth = Math.ceil(dataset.length / this.squaresPerColumn) * this.squareSpacing,
        svgHeight = this.squaresPerColumn * this.squareSpacing;

        //so far, the appropriate color is calculated based on the value of the datum, there is no set of fixed colors
        var colorScale = d3.scaleLinear()
          .domain([datasetMin, datasetMax])
          .range([this.accentcolor, this.primarycolor]);

        var svg = d3.select('#diagram').append('svg')
          .attr('width', svgWidth)
          .attr('height', svgHeight);

        var squares = svg.selectAll('rect')
          .data(data)
          .enter().append('rect')
          .attr('width', this.squareWidth)
          .attr('height', this.squareWidth)
          .attr('x', this._spaceSquareHor)
          .attr('y', this._spaceSquareVert)
          .attr('fill', function(d) { return colorScale(d.y); })
          .on('mouseover', this._showLabel)
          .on('mouseout', this._hideLabel);
      },

      _showLabel: function (d, i) {
        //using a group element 'label' with an appended text element and a rect element as background to display a label

        var polyElement = Polymer.dom(this).parentNode.parentNode.parentNode;
        var label = d3.select('svg').append('g')
          .attr('id', 'label-' + i);

        //append rect element first so that following text element is displayed above rect
        label.append('rect');
        var labelText = label.append('text')
					.text(d.y + ' at ' + d.x)
					.style('font-size', '0.8em')
					.attr('fill', 'black');

        var labelWidth = labelText.node().getBBox().width;
        var labelHeight = labelText.node().getBBox().height;

        //this split is necessary because the position is set relative to the size of the text element
        labelText
          .attr('x', polyElement._spaceLabelHor(d, i, labelWidth))
          .attr('y', polyElement._spaceLabelVert(d, i, labelHeight));

        //finish rect configuration that was appended previously
        label.select('rect')
          .attr('x', labelText.attr('x') - 1)
  				.attr('y', labelText.attr('y') - 0.7 * labelHeight) // 0.7 as factor because labelHeight is bigger than actual height of text
  				.attr('fill', 'white')
  				.attr('width', labelWidth + 1) //ok, so that it doesn't become too short for the text because of the visual offset above
      		.attr('height', 0.8 * labelHeight);
			},

      _hideLabel: function (d, i) {
        d3.select('#label-' + i).remove();
      },

      _spaceLabelHor: function(d, i, labelWidth) {
        var x = this._spaceSquareHor(d, i);
        //calculate the maximum x position possible so that the label won't be cut off on the edge of the SVG
        var maxPosition = d3.select('svg').attr('width') - (this.squareSpacing - this.squareWidth) - labelWidth;

        if(x > maxPosition) { // label would normally be "shown" outside the SVG space
          x = maxPosition;
        }
        return x;
      },

      _spaceLabelVert: function(d, i, labelHeight) {
        var y = this._spaceSquareVert(d, i) - 2;
        if(y < 0) { // label would normally be "shown" just exactly outside the SVG space
          y = this.squareWidth + 0.7 * labelHeight;
        }
        return y;
      },

      _spaceSquareHor: function (d, i) {
        var polyElement = this;
        if (Polymer.dom(this).node.nodeName != "ACTIVITYCHART-BASIC") {
          var polyElement = Polymer.dom(this).parentNode.parentNode.parentNode;
        }
				return polyElement.squareSpacing * (Math.floor(i / polyElement.squaresPerColumn));
			},

      _spaceSquareVert: function (d, i) {
        var polyElement = this;
        if (Polymer.dom(this).node.nodeName != "ACTIVITYCHART-BASIC") {
          var polyElement = Polymer.dom(this).parentNode.parentNode.parentNode;
        }
        return polyElement.squareSpacing * (i % polyElement.squaresPerColumn);
			},
      /**
      * Normalizes the data supplied by the API to work with Plotly
      *
      * @param {Object} data The data (as JSON) to be normalized
      * @return {Array} The normalized data
      */
      _normalizeJSON: function (data) {
        var x = [];
        var y = [];
        for (entry in data) {
          //compute date string
          //x.push(entry);
          x.push((new Date(entry*1000)).toLocaleString());
          y.push(data[entry]);
        }
        var diagramData = {"x":x};
        diagramData["y"] = y;
        diagramData["type"] = "bar";
        diagramData["marker"] = {color:this.primarycolor};
        var plotlyData = [];
        plotlyData.push(diagramData);
        return plotlyData;
      }
    });
  </script>
</dom-module>
