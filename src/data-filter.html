<link rel="import" href="../../polymer/polymer.html">
<link rel="import" href="../../iron-ajax/iron-ajax.html">
<link rel="import" href="../../paper-button/paper-button.html">
<link rel="import" href="plotly-import.html">
<link rel="import" href="linechart-basic.html">


<!--
`data-filter`
This is a component for filtering data based on user input.

@demo demo/data_filter_demo.html
-->
<dom-module id="data-filter">
    <template>
      <style>
        :host {
          display: block;
        }
        #filterBar {
          /*height: 50px;*/
        }
      </style>

      <!-- braucht man hier drunter bei dataurl wirklich die quotes??? -->
      <iron-ajax
          id="ajaxCaller"
          url="[[dataurl]]"
          handle-as="json"
          on-response="handleResponse"
          debounce-duration="300">
      </iron-ajax>

      <div id="filterBar"></div>

      <linechart-basic id="linechart" data="" width={{width}} height={{height}}></linechart-basic>
    </template>

    <script>
        window.addEventListener("WebComponentsReady", function(){
          Polymer({
              is: 'data-filter',

              properties: {
                  /** URL of data to be plotted */
                  dataurl: {
                      type: String,
                      value: "",
                  },
                  /** Data provided as an array of x,y objects */
                  data: {
                      type: Array,
                      value: null,
                  },
                  /** Width of the outer div */
                  width: Number,
                  /** Height of the outer div */
                  height: Number,
                  /** Chose the mode of the linechart,
                  String of value 'markers', 'lines' or 'lines+markers',
                  defaults to 'lines',
                  only works if dataurl is provided and data is not */
                  mode: {
                    type: String,
                    value: 'lines',
                  },
                  /** whitelist of attributes to use as string with delimiter ';'*/
                  whitelist: {
                      type: String,
                      value: 'total_enrollments',
                  },
                  /** list of active attributes (should be subset of whitelist - is not checked) as string with delimiter ';'*/
                  activelist: {
                      type: String,
                      value: 'total_enrollments',
                  },
                  /** what type of format to accept - default and json supported */
                  accept: {
                      type: String,
                      value: 'default',
                  }
              },

              /** This is called by Polymer after the component instance is attached to the document. */
              attached: function() {
                  //TODO make it pretty
                  if(this.accept == 'default') {
                      this.handleDefault();
                  }
                  else {
                      if (!this.data) {
                          this.allResponseData = [];
                          this.$.ajaxCaller.generateRequest();
                      } else {
                          this.plotDiagram();
                      }
                  }
              },

              handleDefault: function() {
                  for (var ii = 0; ii < this.data.length; ii++) {
                      var newButton = document.createElement("paper-button");
                      var buttonText = document.createTextNode("Data " + ii);
                      newButton.appendChild(buttonText);
                      newButton.setAttribute("toggles", "");
                      newButton.setAttribute("raised", "");
                      newButton.setAttribute("on-click", "test");
                      newButton.active = true;
                      newButton.setAttribute("data-array", JSON.stringify(this.data[ii]));
                      this.$.filterBar.appendChild(newButton);
                      this.listen(newButton, 'tap', '_passData');
                  }
              },

              handleResponse: function(response) {
                  this.allResponseData = this.allResponseData.concat(response.detail.response.data);
                  //console.log(response.detail.response.links.next);
                  //console.log(response.detail.response.links.next === undefined);
                  if(response.detail.response.links.next !== undefined) {
                    document.getElementById("ajaxCaller").setAttribute("url", response.detail.response.links.next);
                    this.$.ajaxCaller.generateRequest();
                  } else {
                    this.handleResponseData();
                  }
              },

              handleResponseData: function() {
                // init attribute-data
                this.attributesToBeActive = this.activelist.split(";");
                //console.log(this.attributesToBeActive);
                let attributesToUse = this.whitelist.split(";");

                //let responseData = response.detail.response;
                //responseData = JSON.parse('{"data":[{"type":"course-statistics","id":"4c3c9808-1433-4160-aaa1-89b8f34bf2d1","links":{"self":"/api/v2/course-statistics/4c3c9808-1433-4160-aaa1-89b8f34bf2d1"},"attributes":{"total_enrollments":198,"current_enrollments":198,"no_shows":197,"total_questions":4,"total_answers":3,"total_comments_on_answers":2,"total_comments_on_questions":103,"new_users":200,"updated_at":"2016-11-11T08:17:52.068Z","created_at":"2016-11-11T08:17:51.868Z"},"relationships":{"course":{"data":{"type":"courses","id":"00000001-3300-4444-9999-000000000001"},"links":{"related":"/api/v2/courses/00000001-3300-4444-9999-000000000001"}}}},{"type":"course-statistics","id":"4c3c9808-1433-4160-aaa1-89b8f34bf2d1","links":{"self":"/api/v2/course-statistics/4c3c9808-1433-4160-aaa1-89b8f34bf2d1"},"attributes":{"total_enrollments":199,"current_enrollments":199,"no_shows":198,"total_questions":4,"total_answers":3,"total_comments_on_answers":2,"total_comments_on_questions":103,"new_users":200,"updated_at":"2017-03-07T13:21:15.885Z","created_at":"2016-11-11T08:17:51.868Z"},"relationships":{"course":{"data":{"type":"courses","id":"00000001-3300-4444-9999-000000000001"},"links":{"related":"/api/v2/courses/00000001-3300-4444-9999-000000000001"}}}}],"meta":{"current_page":1,"total_pages":1},"links":{"first":"http://0.0.0.0:3000/api/v2/course-statistics?filter%5Bcourse_id%5D=00000001-3300-4444-9999-000000000001&filter%5Bhistoric_data%5D=true&page%5Bnumber%5D=1","last":"http://0.0.0.0:3000/api/v2/course-statistics?filter%5Bcourse_id%5D=00000001-3300-4444-9999-000000000001&filter%5Bhistoric_data%5D=true&page%5Bnumber%5D=1"}}');
                let timeline = [];

                // add all timestamps to timeline
                let counter = 0;
                for(let i = 0; i < this.allResponseData.length; i++) {
                    let updatedAt = this.allResponseData[i].attributes.updated_at;
                    timeline.push(updatedAt);
                    counter++;
                }
                console.log(counter + ' entries');

                // is going to store the y-data for all lines as tempObject = { attributeName1: [...], attributeName2: [...], ... }
                this.tempObject = {};

                // initialize tempObject's properties as Arrays
                for(let i=0; i < attributesToUse.length; i++) {
                    this.tempObject[attributesToUse[i]] = [];
                    //console.log(attributesToUse[i]);
                }

                // add attribute-specific data of all data points to its corresponding attribute
                for(let i = 0; i < this.allResponseData.length; i++) {
                    let entryAttributes = this.allResponseData[i].attributes
                    for(let j=0; j < attributesToUse.length; j++) {
                        this.tempObject[attributesToUse[j]].push(entryAttributes[attributesToUse[j]]);
                        //console.log(entryAttributes[attributesToUse[j]]);
                    }
                }

                this.data = [];
                for(key in this.tempObject) {
                  let dataElement = {
                      x: timeline,
                      y: this.tempObject[key],
                      name: key,
                      mode: this.mode,
                  }
                  //console.log(this.mode);
                  this.data.push(dataElement);
                }

                this.plotDiagram()
              },

              plotDiagram: function() {
                //this.$.linechart.data = this.data;
                let i = 0;
                if (this.tempObject) {
                  for (let key in this.tempObject) {
                      let newButton = document.createElement("paper-button");
                      let buttonText = document.createTextNode(key);
                      newButton.appendChild(buttonText);
                      newButton.setAttribute("toggles", "");
                      newButton.setAttribute("raised", "");
                      //set button only on active when it should be
                      newButton.active = this.attributesToBeActive.indexOf(key) > -1;
                      newButton.setAttribute("data-array", JSON.stringify(this.data[i]));
                      this.$.filterBar.appendChild(newButton);
                      this.listen(newButton, 'tap', '_passData');
                      i++;
                  }
                } else {
                  for (let i = 0; i < this.data.length; i++) {
                    let newButton = document.createElement("paper-button");
                    let buttonText = document.createTextNode("Data " + i);
                    newButton.appendChild(buttonText);
                    newButton.setAttribute("toggles", "");
                    newButton.setAttribute("raised", "");
                    //set button only on active when it should be
                    newButton.active = this.attributesToBeActive.indexOf(key) > -1;
                    newButton.setAttribute("data-array", JSON.stringify(this.data[i]));
                    this.$.filterBar.appendChild(newButton);
                    this.listen(newButton, 'tap', '_passData');
                  }
                }
                //initialize dataset of chart
                let newDataset = [];
                const buttons = this.$.filterBar.children;
                for (let i = 0; i < buttons.length; i++) {
                    if (buttons[i].active) {
                        newDataset.push(JSON.parse(buttons[i].getAttribute("data-array")));
                    }
                }
                this.$.linechart.data = newDataset;
              },

              /**
              *
              * Acts as an eventhandler and is called every time a button is pressed.
              * It then alters the data array corresponding to the active buttons and passes
              * the data to the contained linechart element.
              *
              * @param {button} button the button that was pressed
              */
              _passData: function(button) {
                  let newDataset = [];
                  const buttons = this.$.filterBar.children;
                  for (let i = 0; i < buttons.length; i++) {
                      if (buttons[i].active) {
                          newDataset.push(JSON.parse(buttons[i].getAttribute("data-array")));
                      }
                  }
                  this.$.linechart.data = newDataset;
              },
          });
    });
    </script>
</dom-module>
